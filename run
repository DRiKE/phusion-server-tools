#!/usr/bin/env ruby
require File.expand_path(File.dirname(__FILE__) + '/shared')
ENV['PATH'] = OLD_PATH
STDOUT.sync = STDERR.sync = true

require 'rubygems'
require 'optparse'
require 'escape'

OPTIONS = {}

def parse_options
	parser = OptionParser.new do |opts|
		nl = "\n" + ' ' * 37
		opts.banner = "Usage: ./run-in-background [options] COMMAND..."
		opts.separator ""
		
		opts.separator "Options:"
		opts.on("--log-file FILE") do |value|
			OPTIONS[:log_file] = value
		end
		opts.on("--syslog") do
			OPTIONS[:syslog] = true
		end
		opts.on("--status-file FILE") do |value|
			OPTIONS[:status_file] = value
		end
		opts.on("--lock-file FILE") do |value|
			OPTIONS[:lock_file] = value
		end
		opts.on("--email-to ADDRESSES", "Separated by comma") do |value|
			OPTIONS[:email_to] = value
		end
	end
	begin
		parser.parse!
	rescue OptionParser::ParseError => e
		STDERR.puts e
		STDERR.puts
		STDERR.puts "Please see '--help' for valid options."
		exit 1
	end

	if !OPTIONS[:log_file] && !OPTIONS[:syslog]
		abort "You must specify either '--log-file' or '--syslog'! See '--help'."
	elsif ARGV.size < 1
		STDERR.puts parser
		exit 1
	end
end

def start
	parse_options

	program_name = File.basename(ARGV[0])
	begin
		lock_file = create_lock_file

		if OPTIONS[:log_file]
			File.open(OPTIONS[:log_file], 'w').close
		end
		write_status_file('')

		a, b = IO.pipe
		command_pid = fork do
			a.close
			STDIN.reopen("/dev/null", "r")
			STDOUT.reopen(b)
			STDERR.reopen(b)
			exec(*ARGV)
		end
		if OPTIONS[:syslog]
			output_sink_pid = fork do
				b.close
				STDIN.reopen(a)
				STDERR.reopen(STDOUT)
				# Don't let terminal signals reach this process.
				Process.setsid
				exec("#{TOOLS_DIR}/syslog-tee", "-t", "#{program_name}[#{command_pid}]")
			end
		else
			output_sink_pid = fork do
				b.close
				STDIN.reopen(a)
				# Don't let terminal signals reach this process.
				Process.setsid
				exec("tee", OPTIONS[:log_file])
			end
		end
		a.close
		b.close

		while true
			begin
				Process.waitpid(command_pid)
				exit_code = ($?.exitstatus || 2)
				command_pid = nil
				break
			rescue Errno::ECHILD
				exit_code = 1
				command_pid = nil
				break
			rescue SignalException => e
				signame = get_signal_name(e)
				Process.kill(signame, command_pid)
			end
		end

		# TODO: are we supposed to wait for the output sink process?
		# If we only wait for the command then the output sink process
		# may not have finished processing all the output yet.
		# But if we wait for both, and the command spawns subprocesses,
		# then the output sink process doesn't exit until all those
		# subprocesses have also exited. Maybe we should provide a
		# command line option for this.
		begin
			Process.waitpid(output_sink_pid)
		rescue Errno::ECHILD
			# Ignore exception.
		end
		output_sink_pid = nil

		write_status_file(exit_code)
		if OPTIONS[:email_to]
			email(
				OPTIONS[:email_from],
				OPTIONS[:email_to],
				"Command finished with exit code #{exit_code}: #{ARGV.join(' ')}",
				
				"Command: #{ARGV.join(' ')}\n" +
				"Exit code: #{exit_code}\n" +
				"Host: #{`hostname`.strip}\n" +
				"Log file: #{OPTIONS[:log_file]}\n"
			)
		end
		exit(exit_code)

	rescue SystemExit
		raise
	
	rescue Exception => e
		if OPTIONS[:log_file]
			f = File.open(OPTIONS[:log_file], 'a')
		else
			f = IO.popen("logger -t '#{program_name}:runner[#{$$}]'", "w")
		end
		begin
			f.puts("#{e.class}: #{e.message || e}\n  " +
				e.backtrace.join("\n  "))
		ensure
			f.close
		end
		Process.kill('SIGTERM', command_pid) if command_pid
		raise e

	ensure
		delete_lock_file(lock_file) if lock_file
	end
end

def get_signal_name(signal_exception)
	if signal_exception.is_a?(Interrupt)
		return "SIGINT"
	else
		return signal_exception.signm
	end
end

def create_lock_file
	if OPTIONS[:lock_file]
		File.open(OPTIONS[:lock_file], File::WRONLY | File::EXCL | File::CREAT) do |f|
			f.puts Process.pid
		end
		return true
	else
		return nil
	end
rescue Errno::EEXIST
	raise "Lock file #{OPTIONS[:lock_file]} already exists!"
end

def delete_lock_file(lock_file)
	File.unlink(OPTIONS[:lock_file])
end

def write_status_file(content)
	if OPTIONS[:status_file]
		File.open(OPTIONS[:status_file], "w") do |f|
			f.write(content.to_s)
		end
	end
end

start
